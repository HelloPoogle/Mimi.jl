{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Mimi\n\n\n\n\nOverview\n\n\nMimi is a package that provides a component model for integrated assessment models.\n\n\n\n\nInstallation\n\n\nMimi is an installable package. To install Mimi, use the following:\n\n\nPkg.add(\nMimi\n)\n\n\n\n\nFor more complete setup instructions, follow the \nInstallation Guide\n.\n\n\n\n\nModels using Mimi\n\n\n\n\nFUND.jl\n (currently in beta)\n\n\nMimi-DICE.jl and Mimi-RICE.jl (currently in closed beta)\n\n\nMimi-SNEASY.jl (currently in closed beta)", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mimi", 
            "text": "", 
            "title": "Welcome to Mimi"
        }, 
        {
            "location": "/#overview", 
            "text": "Mimi is a package that provides a component model for integrated assessment models.", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "Mimi is an installable package. To install Mimi, use the following:  Pkg.add( Mimi )  For more complete setup instructions, follow the  Installation Guide .", 
            "title": "Installation"
        }, 
        {
            "location": "/#models-using-mimi", 
            "text": "FUND.jl  (currently in beta)  Mimi-DICE.jl and Mimi-RICE.jl (currently in closed beta)  Mimi-SNEASY.jl (currently in closed beta)", 
            "title": "Models using Mimi"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation Guide\n\n\nThis guide will briefly explain how to install julia and Mimi.\n\n\n\n\nInstalling julia\n\n\nMimi requires the programming language \njulia\n to run. You can download the current release from the julia \ndownload page\n. You should download and install the command line version from that page.\n\n\n\n\nInstalling Mimi\n\n\nOnce julia is installed, start julia and you should see a julia command prompt. To install the Mimi package, issue the following command:\n\n\njulia\n Pkg.add(\nMimi\n)\n\n\n\n\nYou only have to run this command once on your machine.\n\n\nAs Mimi gets improved we will release new versions of the package. To make sure you always have the latest version of Mimi installed, you can run the following command at the julia prompt:\n\n\njulia\n Pkg.update()\n\n\n\n\nThis will update \nall\n installed packages to their latest version (not just the Mimi package).\n\n\n\n\nUsing Mimi\n\n\nWhen you start a new julia command prompt, Mimi is not yet loaded into that julia session. To load Mimi, issue the following command:\n\n\njulia\n using Mimi\n\n\n\n\nYou will have to run this command every time you want to use Mimi in julia. You would typically also add \nusing Mimi\n to the top of any julia code file that for example defines Mimi components.\n\n\n\n\nEditor support\n\n\nThere are various editors around that have julia support:\n\n\n\n\nIJulia\n adds julia support to the \njupyter\n (formerly IPython) notebook system.\n\n\nJuno\n adds julia specific features to the \nAtom\n editor. It currently is the closest to a fully featured julia IDE.\n\n\nSublime\n, \nVS Code\n, \nEmacs\n and many other editors all have julia extensions that add various levels of support for the julia language.\n\n\n\n\n\n\nGetting started\n\n\nThe best way to get started with Mimi is to work through the \nTutorial\n. The \nexamples/tutorial\n folder in the \nMimi\n github repository has julia code files that completely implement the example described in the tutorial.\n\n\nThe \nMimi\n github repository also has links to various models that are based on Mimi, and looking through their code can be instructive.\n\n\nFinally, when in doubt, ask your question in the \nMimi gitter chatroom\n or send an email to \nDavid Anthoff\n (\n) and ask for help. Don't be shy about either option, we would much prefer to be inundated with lots of questions and help people out than people give up on Mimi!", 
            "title": "Installation Guide"
        }, 
        {
            "location": "/installation/#installation-guide", 
            "text": "This guide will briefly explain how to install julia and Mimi.", 
            "title": "Installation Guide"
        }, 
        {
            "location": "/installation/#installing-julia", 
            "text": "Mimi requires the programming language  julia  to run. You can download the current release from the julia  download page . You should download and install the command line version from that page.", 
            "title": "Installing julia"
        }, 
        {
            "location": "/installation/#installing-mimi", 
            "text": "Once julia is installed, start julia and you should see a julia command prompt. To install the Mimi package, issue the following command:  julia  Pkg.add( Mimi )  You only have to run this command once on your machine.  As Mimi gets improved we will release new versions of the package. To make sure you always have the latest version of Mimi installed, you can run the following command at the julia prompt:  julia  Pkg.update()  This will update  all  installed packages to their latest version (not just the Mimi package).", 
            "title": "Installing Mimi"
        }, 
        {
            "location": "/installation/#using-mimi", 
            "text": "When you start a new julia command prompt, Mimi is not yet loaded into that julia session. To load Mimi, issue the following command:  julia  using Mimi  You will have to run this command every time you want to use Mimi in julia. You would typically also add  using Mimi  to the top of any julia code file that for example defines Mimi components.", 
            "title": "Using Mimi"
        }, 
        {
            "location": "/installation/#editor-support", 
            "text": "There are various editors around that have julia support:   IJulia  adds julia support to the  jupyter  (formerly IPython) notebook system.  Juno  adds julia specific features to the  Atom  editor. It currently is the closest to a fully featured julia IDE.  Sublime ,  VS Code ,  Emacs  and many other editors all have julia extensions that add various levels of support for the julia language.", 
            "title": "Editor support"
        }, 
        {
            "location": "/installation/#getting-started", 
            "text": "The best way to get started with Mimi is to work through the  Tutorial . The  examples/tutorial  folder in the  Mimi  github repository has julia code files that completely implement the example described in the tutorial.  The  Mimi  github repository also has links to various models that are based on Mimi, and looking through their code can be instructive.  Finally, when in doubt, ask your question in the  Mimi gitter chatroom  or send an email to  David Anthoff  ( ) and ask for help. Don't be shy about either option, we would much prefer to be inundated with lots of questions and help people out than people give up on Mimi!", 
            "title": "Getting started"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Tutorial\n\n\n\n\nConstructing A One-Region Model\n\n\nIn this example, we will construct a stylized model of the global economy and its changing greenhouse gas emission levels through time. The overall strategy will involve creating components for the economy and emissions separately, and then defining a model where the two components are coupled together.\n\n\nThere are two main steps to creating a component:\n\n\n\n\nDefine the component using \n@defcomp\n where the parameters and variables are listed.\n\n\nUse the run_timestep function \nrun_timestep(state::component_name, t::Int)\n to set the equations of that component.\n\n\n\n\nStarting with the economy component, each variable and parameter is listed. If either varialbes or parameters have a time-dimension, that must be set with \n(index=[time])\n.\n\n\nusing Mimi\n\n@defcomp grosseconomy begin\n    YGROSS  = Variable(index=[time])    #Gross output\n    K       = Variable(index=[time])    #Capital\n    l       = Parameter(index=[time])   #Labor\n    tfp     = Parameter(index=[time])   #Total factor productivity\n    s       = Parameter(index=[time])   #Savings rate\n    depk    = Parameter()               #Depreciation rate on capital - Note that it has no time index\n    k0      = Parameter()               #Initial level of capital\n    share   = Parameter()               #Capital share\nend\n\n\n\n\nNext, the run_timestep function must be defined along with the various equations of the \ngrosseconomy\n component. In this step, the variables and parameters are linked to this component by \nstate\n and must be identified as either a variable or a parameter in each equation. For this example, \nv\n will refer to variables while \np\n refers to paremeters.\n\n\nfunction run_timestep(state::grosseconomy, t::Int)\n    v = state.Variables\n    p = state.Parameters\n\n    #Define an equation for K\n    if t == 1\n        v.K[t]  = p.k0  #Note the use of v. and p. to distinguish between variables and parameters\n    else\n        v.K[t]  = (1 - p.depk)^5 * v.K[t-1] + v.YGROSS[t-1] * p.s[t-1] * 5\n    end\n\n    #Define an equation for YGROSS\n    v.YGROSS[t] = p.tfp[t] * v.K[t]^p.share * p.l[t]^(1-p.share)\nend\n\n\n\n\nNext, the the component for greenhouse gas emissions must be created.  Although the steps are the same as for the \ngrosseconomy\n component, there is one minor difference. While \nYGROSS\n was a variable in the \ngrosseconomy\n component, it now enters the \nemissions\n component as a parameter. This will be true for any variable that becomes a parameter for another component in the model.\n\n\n@defcomp emissions begin\n    E       = Variable(index=[time])    #Total greenhouse gas emissions\n    sigma   = Parameter(index=[time])   #Emissions output ratio\n    YGROSS  = Parameter(index=[time])   #Gross output - Note that YGROSS is now a parameter\nend\n\n\n\n\nfunction run_timestep(state::emissions, t::Int)\n    v = state.Variables\n    p = state.Parameters\n\n    #Define an eqation for E\n    v.E[t] = p.YGROSS[t] * p.sigma[t]   #Note the p. in front of YGROSS\nend\n\n\n\n\nWe can now use Mimi to construct a model that binds the \ngrosseconomy\n and \nemissions\n components together in order to solve for the emissions level of the global economy over time. In this example, we will run the model for twenty periods with a timestep of five years between each period.\n\n\n\n\nOnce the model is defined, \nsetindex\n is used to set the length and interval of the time step.\n\n\nWe then use \naddcomponent\n to incorporate each component that we previously created into the model.  It is important to note that the order in which the components are listed here matters.  The model will run through each equation of the first component before moving onto the second component.\n\n\nNext, \nsetparameter\n is used to assign values to each parameter in the model, with parameters being uniquely tied to each component. If \npopulation\n was a parameter for two different components, it must be assigned to each one using \nsetparameter\n two different times. The syntax is \nsetparameter(model_name, :component_name, :parameter_name, value)\n\n\nIf any variables of one component are parameters for another, \nconnectparameter\n is used to couple the two components together. In this example, \nYGROSS\n is a variable in the \ngrosseconomy\n component and a parameter in the \nemissions\n component. The syntax is \nconnectparameter(model_name, :component_name_current, :parameter_name, :component_name_variable)\n, where \n:component_name_variable\n refers to the component where your parameter was initially calculated as a variable.\n\n\nFinally, the model can be run using the command \nrun(model_name)\n.\n\n\nTo access model results, use \nmodel_name[:component, :variable_name]\n.\n\n\n\n\nmy_model = Model()\n\nsetindex(my_model, :time, [2015:5:2110])\n\naddcomponent(my_model, grosseconomy)  #Order matters here. If the emissions component were defined first, the model would not run.\naddcomponent(my_model, emissions)\n\n#Set parameters for the grosseconomy component\nsetparameter(my_model, :grosseconomy, :l, [(1. + 0.015)^t *6404 for t in 1:20])\nsetparameter(my_model, :grosseconomy, :tfp, [(1 + 0.065)^t * 3.57 for t in 1:20])\nsetparameter(my_model, :grosseconomy, :s, ones(20).* 0.22)\nsetparameter(my_model, :grosseconomy, :depk, 0.1)\nsetparameter(my_model, :grosseconomy, :k0, 130.)\nsetparameter(my_model, :grosseconomy, :share, 0.3)\n\n#Set parameters for the emissions component\nsetparameter(my_model, :emissions, :sigma, [(1. - 0.05)^t *0.58 for t in 1:20])\nconnectparameter(my_model, :emissions, :YGROSS, :grosseconomy, :YGROSS)  #Note that connectparameter was used here.\n\nrun(my_model)\n\n#Check model results\nmy_model[:emissions, :E]\n\n\n\n\n\n\nConstructing A Multi-Region Model\n\n\nWe can now modify our two-component model of the globe to include multiple regional economies.  Global greenhouse gas emissions will now be the sum of regional emissions. The modeling approach is the same, with a few minor adjustments:\n\n\n\n\nWhen using \n@defcomp\n, a regions index must be specified. In addition, for variables that have a regional index it is necessary to include \n(index=[regions])\n. This can be combined with the time index as well, \n(index=[time, regions])\n.\n\n\nIn the run_timestep function, a region dimension must be defined using \nstate.Dimensions\n.  Unlike the time dimension, regions must be specified and looped through in any equations that contain a regional variable or parameter.\n\n\nsetindex\n must be used to specify your regions in the same way that it is used to specify your timestep.\n\n\nWhen using \nsetparameter\n for values with a time and regional dimension, an array is used.  Each row corresponds to a time step, while each column corresponds to a separate region. For regional values with no timestep, a vector can be used. It is often easier to create an array of parameter values before model construction. This way, the parameter name can be entered into \nsetparameter\n rather than an entire equation.\n\n\nWhen constructing regionalized models with multiple components, it is often easier to save each component as a separate file and to then write a function that constructs the model.  When this is done, \nusing Mimi\n must be speficied for each component. This approach will be used here.\n\n\n\n\nTo create a three-regional model, we will again start by constructing the grosseconomy and emissions components, making adjustments for the regional index as needed.  Each component should be saved as a separate file.\n\n\nusing Mimi\n\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\nend\n\n\nfunction run_timestep(state::grosseconomy, t::Int)\n    v = state.Variables\n    p = state.Parameters\n    d = state.Dimensions                        #Note that the regional dimension is defined here and parameters and variables are indexed by 'r'\n\n    #Define an equation for K\n    for r in d.regions\n        if t == 1\n            v.K[t,r] = p.k0[r]\n        else\n            v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n        end\n    end\n\n    #Define an equation for YGROSS\n    for r in d.regions\n        v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n    end\nend\n\n\n\n\nSave this component as \ngross_economy.jl\n\n\nusing Mimi                                          #Make sure to call Mimi again\n\n@defcomp emissions begin\n    regions     = Index()                           #The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   #Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            #Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  #Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  #Gross output - Note that YGROSS is now a parameter\nend\n\n\nfunction run_timestep(state::emissions, t::Int)\n    v = state.Variables\n    p = state.Parameters\n    d = state.Dimensions\n\n    #Define an eqation for E\n    for r in d.regions\n        v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n    end\n\n    #Define an equation for E_Global\n    for r in d.regions\n        v.E_Global[t] = sum(v.E[t,:])\n    end\nend\n\n\n\n\nSave this component as \nemissions.jl\n\n\nLet's create a file with all of our parameters that we can call into our model.  This will help keep things organized as the number of components and regions increases. Each column refers to parameter values for a region, reflecting differences in initial parameter values and growth rates between the three regions.\n\n\nl = Array(Float64,20,3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array(Float64,20,3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array(Float64,20,3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array(Float64,20,3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend\n\n\n\n\nSave this file as \nregion_parameters.jl\n\n\nThe final step is to create a function that will run our model.\n\n\ninclude(\ngross_economy.jl\n)\ninclude(\nemissions.jl\n)\n\nfunction run_my_model()\n\n    my_model = Model()\n\n    setindex(my_model, :time, [2015:5:2110])\n    setindex(my_model, :regions, [\nRegion1\n, \nRegion2\n, \nRegion3\n])  #Note that the regions of your model must be specified here\n\n    addcomponent(my_model, grosseconomy)\n    addcomponent(my_model, emissions)\n\n    setparameter(my_model, :grosseconomy, :l, l)\n    setparameter(my_model, :grosseconomy, :tfp, tfp)\n    setparameter(my_model, :grosseconomy, :s, s)\n    setparameter(my_model, :grosseconomy, :depk,depk)\n    setparameter(my_model, :grosseconomy, :k0, k0)\n    setparameter(my_model, :grosseconomy, :share, 0.3)\n\n    #set parameters for emissions component\n    setparameter(my_model, :emissions, :sigma, sigma)\n    connectparameter(my_model, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    run(my_model)\n    return(my_model)\n\nend\n\n\n\n\nWe can now call in our parameter file, use \nrun_my_model\n to construct our model, and evaluate the results.\n\n\nusing Mimi\ninclude(\nregion_parameters.jl\n)\n\nrun1 = run_my_model()\n\n#Check results\nrun1[:emissions, :E_Global]", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tutorial", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#constructing-a-one-region-model", 
            "text": "In this example, we will construct a stylized model of the global economy and its changing greenhouse gas emission levels through time. The overall strategy will involve creating components for the economy and emissions separately, and then defining a model where the two components are coupled together.  There are two main steps to creating a component:   Define the component using  @defcomp  where the parameters and variables are listed.  Use the run_timestep function  run_timestep(state::component_name, t::Int)  to set the equations of that component.   Starting with the economy component, each variable and parameter is listed. If either varialbes or parameters have a time-dimension, that must be set with  (index=[time]) .  using Mimi\n\n@defcomp grosseconomy begin\n    YGROSS  = Variable(index=[time])    #Gross output\n    K       = Variable(index=[time])    #Capital\n    l       = Parameter(index=[time])   #Labor\n    tfp     = Parameter(index=[time])   #Total factor productivity\n    s       = Parameter(index=[time])   #Savings rate\n    depk    = Parameter()               #Depreciation rate on capital - Note that it has no time index\n    k0      = Parameter()               #Initial level of capital\n    share   = Parameter()               #Capital share\nend  Next, the run_timestep function must be defined along with the various equations of the  grosseconomy  component. In this step, the variables and parameters are linked to this component by  state  and must be identified as either a variable or a parameter in each equation. For this example,  v  will refer to variables while  p  refers to paremeters.  function run_timestep(state::grosseconomy, t::Int)\n    v = state.Variables\n    p = state.Parameters\n\n    #Define an equation for K\n    if t == 1\n        v.K[t]  = p.k0  #Note the use of v. and p. to distinguish between variables and parameters\n    else\n        v.K[t]  = (1 - p.depk)^5 * v.K[t-1] + v.YGROSS[t-1] * p.s[t-1] * 5\n    end\n\n    #Define an equation for YGROSS\n    v.YGROSS[t] = p.tfp[t] * v.K[t]^p.share * p.l[t]^(1-p.share)\nend  Next, the the component for greenhouse gas emissions must be created.  Although the steps are the same as for the  grosseconomy  component, there is one minor difference. While  YGROSS  was a variable in the  grosseconomy  component, it now enters the  emissions  component as a parameter. This will be true for any variable that becomes a parameter for another component in the model.  @defcomp emissions begin\n    E       = Variable(index=[time])    #Total greenhouse gas emissions\n    sigma   = Parameter(index=[time])   #Emissions output ratio\n    YGROSS  = Parameter(index=[time])   #Gross output - Note that YGROSS is now a parameter\nend  function run_timestep(state::emissions, t::Int)\n    v = state.Variables\n    p = state.Parameters\n\n    #Define an eqation for E\n    v.E[t] = p.YGROSS[t] * p.sigma[t]   #Note the p. in front of YGROSS\nend  We can now use Mimi to construct a model that binds the  grosseconomy  and  emissions  components together in order to solve for the emissions level of the global economy over time. In this example, we will run the model for twenty periods with a timestep of five years between each period.   Once the model is defined,  setindex  is used to set the length and interval of the time step.  We then use  addcomponent  to incorporate each component that we previously created into the model.  It is important to note that the order in which the components are listed here matters.  The model will run through each equation of the first component before moving onto the second component.  Next,  setparameter  is used to assign values to each parameter in the model, with parameters being uniquely tied to each component. If  population  was a parameter for two different components, it must be assigned to each one using  setparameter  two different times. The syntax is  setparameter(model_name, :component_name, :parameter_name, value)  If any variables of one component are parameters for another,  connectparameter  is used to couple the two components together. In this example,  YGROSS  is a variable in the  grosseconomy  component and a parameter in the  emissions  component. The syntax is  connectparameter(model_name, :component_name_current, :parameter_name, :component_name_variable) , where  :component_name_variable  refers to the component where your parameter was initially calculated as a variable.  Finally, the model can be run using the command  run(model_name) .  To access model results, use  model_name[:component, :variable_name] .   my_model = Model()\n\nsetindex(my_model, :time, [2015:5:2110])\n\naddcomponent(my_model, grosseconomy)  #Order matters here. If the emissions component were defined first, the model would not run.\naddcomponent(my_model, emissions)\n\n#Set parameters for the grosseconomy component\nsetparameter(my_model, :grosseconomy, :l, [(1. + 0.015)^t *6404 for t in 1:20])\nsetparameter(my_model, :grosseconomy, :tfp, [(1 + 0.065)^t * 3.57 for t in 1:20])\nsetparameter(my_model, :grosseconomy, :s, ones(20).* 0.22)\nsetparameter(my_model, :grosseconomy, :depk, 0.1)\nsetparameter(my_model, :grosseconomy, :k0, 130.)\nsetparameter(my_model, :grosseconomy, :share, 0.3)\n\n#Set parameters for the emissions component\nsetparameter(my_model, :emissions, :sigma, [(1. - 0.05)^t *0.58 for t in 1:20])\nconnectparameter(my_model, :emissions, :YGROSS, :grosseconomy, :YGROSS)  #Note that connectparameter was used here.\n\nrun(my_model)\n\n#Check model results\nmy_model[:emissions, :E]", 
            "title": "Constructing A One-Region Model"
        }, 
        {
            "location": "/tutorial/#constructing-a-multi-region-model", 
            "text": "We can now modify our two-component model of the globe to include multiple regional economies.  Global greenhouse gas emissions will now be the sum of regional emissions. The modeling approach is the same, with a few minor adjustments:   When using  @defcomp , a regions index must be specified. In addition, for variables that have a regional index it is necessary to include  (index=[regions]) . This can be combined with the time index as well,  (index=[time, regions]) .  In the run_timestep function, a region dimension must be defined using  state.Dimensions .  Unlike the time dimension, regions must be specified and looped through in any equations that contain a regional variable or parameter.  setindex  must be used to specify your regions in the same way that it is used to specify your timestep.  When using  setparameter  for values with a time and regional dimension, an array is used.  Each row corresponds to a time step, while each column corresponds to a separate region. For regional values with no timestep, a vector can be used. It is often easier to create an array of parameter values before model construction. This way, the parameter name can be entered into  setparameter  rather than an entire equation.  When constructing regionalized models with multiple components, it is often easier to save each component as a separate file and to then write a function that constructs the model.  When this is done,  using Mimi  must be speficied for each component. This approach will be used here.   To create a three-regional model, we will again start by constructing the grosseconomy and emissions components, making adjustments for the regional index as needed.  Each component should be saved as a separate file.  using Mimi\n\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\nend\n\n\nfunction run_timestep(state::grosseconomy, t::Int)\n    v = state.Variables\n    p = state.Parameters\n    d = state.Dimensions                        #Note that the regional dimension is defined here and parameters and variables are indexed by 'r'\n\n    #Define an equation for K\n    for r in d.regions\n        if t == 1\n            v.K[t,r] = p.k0[r]\n        else\n            v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n        end\n    end\n\n    #Define an equation for YGROSS\n    for r in d.regions\n        v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n    end\nend  Save this component as  gross_economy.jl  using Mimi                                          #Make sure to call Mimi again\n\n@defcomp emissions begin\n    regions     = Index()                           #The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   #Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            #Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  #Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  #Gross output - Note that YGROSS is now a parameter\nend\n\n\nfunction run_timestep(state::emissions, t::Int)\n    v = state.Variables\n    p = state.Parameters\n    d = state.Dimensions\n\n    #Define an eqation for E\n    for r in d.regions\n        v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n    end\n\n    #Define an equation for E_Global\n    for r in d.regions\n        v.E_Global[t] = sum(v.E[t,:])\n    end\nend  Save this component as  emissions.jl  Let's create a file with all of our parameters that we can call into our model.  This will help keep things organized as the number of components and regions increases. Each column refers to parameter values for a region, reflecting differences in initial parameter values and growth rates between the three regions.  l = Array(Float64,20,3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array(Float64,20,3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array(Float64,20,3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array(Float64,20,3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend  Save this file as  region_parameters.jl  The final step is to create a function that will run our model.  include( gross_economy.jl )\ninclude( emissions.jl )\n\nfunction run_my_model()\n\n    my_model = Model()\n\n    setindex(my_model, :time, [2015:5:2110])\n    setindex(my_model, :regions, [ Region1 ,  Region2 ,  Region3 ])  #Note that the regions of your model must be specified here\n\n    addcomponent(my_model, grosseconomy)\n    addcomponent(my_model, emissions)\n\n    setparameter(my_model, :grosseconomy, :l, l)\n    setparameter(my_model, :grosseconomy, :tfp, tfp)\n    setparameter(my_model, :grosseconomy, :s, s)\n    setparameter(my_model, :grosseconomy, :depk,depk)\n    setparameter(my_model, :grosseconomy, :k0, k0)\n    setparameter(my_model, :grosseconomy, :share, 0.3)\n\n    #set parameters for emissions component\n    setparameter(my_model, :emissions, :sigma, sigma)\n    connectparameter(my_model, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    run(my_model)\n    return(my_model)\n\nend  We can now call in our parameter file, use  run_my_model  to construct our model, and evaluate the results.  using Mimi\ninclude( region_parameters.jl )\n\nrun1 = run_my_model()\n\n#Check results\nrun1[:emissions, :E_Global]", 
            "title": "Constructing A Multi-Region Model"
        }, 
        {
            "location": "/faq/", 
            "text": "Frequently asked questions\n\n\n\n\nWhat's up with the name?\n\n\nThe name is probably an acronym for \"Modular Integrated Modeling Interface\", but we are not sure. What is certain is that it came up during a dinner that \nBob\n, \nDavid\n and \nSol\n had in 2015. David thinks that Bob invented the name, Bob doesn't remember and Sol thinks the waiter might have come up with it (although we can almost certainly rule that option out). It certainly is better than the previous name \"IAMF\". We now use \"Mimi\" purely as a name of the package, not as an acronym.\n\n\n\n\nHow do I use a multivariate distribution for a parameter within a component?\n\n\nYou might want to use a multivariate distribution to capture the covariance between estimated coefficient parameters.  For example, an estimated polynomial can be represented as a multivariate Normal distribution, with a variance-covariance matrix.  Do use this, define the parameter in the component with a vector type, like here:\n\n\n@defcomp example begin\n    cubiccoeffs::Vector{Float64} = Parameter()\nend\n\n\n\n\nThen in the model construction, set the parameter with a multivariate distribution (here the parameters are loaded from a CSV file):\n\n\ncubicparams = readdlm(\n../data/cubicparams.csv\n, ',')\nsetparameter(m, :example, :cubiccoeff, MvNormal(squeeze(cubicparams[1,:], 1), cubicparams[2:4,:]))\n\n\n\n\nHere, \n../data/cubicparams.csv\n is a parameter definition file that looks something like this:\n\n\n# Example estimated polynomial parameter\n# First line: linear, quadratic, cubic\n# Lines 2-4: covariance matrix\n-3.233303,1.911123,-.1018884\n1.9678593,-.57211657,.04413228\n-.57211657,.17500949,-.01388863\n.04413228,-.01388863,.00111965\n\n\n\n\n\n\nHow do I use component references?\n\n\nComponent references allow you to write cleaner model code when connecting components.  The \naddcomponent\n function returns a reference to the component that you just added:\n\n\nmycomponent = addcomponent(model, MyComponent)\n\n\n\n\nIf you want to get a reference to a component after the \naddcomponent\n call has been made, you can construct the reference as:\n\n\nmycomponent = ComponentReference(model, :MyComponent)\n\n\n\n\nYou can use this component reference in place of the \nsetparameter\n and \nconnectparameter\n calls.\n\n\n\n\nReferences in place of \nsetparameter\n\n\nThe line \nsetparameter(model, :MyComponent, :myparameter, myvalue)\n can be written as \nmycomponent[:myparameter] = myvalue\n, where \nmycomponent\n is a component reference.\n\n\n\n\nReferences in place of \nconnectparameter\n\n\nThe line \nconnectparameter(model, :MyComponent, :myparameter, :YourComponent, :yourparameter)\n can be written as \nmycomponent[:myparameter] = yourcomponent[:yourparameter]\n, where \nmycomponent\n and \nyourcomponent\n are component references.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#frequently-asked-questions", 
            "text": "", 
            "title": "Frequently asked questions"
        }, 
        {
            "location": "/faq/#whats-up-with-the-name", 
            "text": "The name is probably an acronym for \"Modular Integrated Modeling Interface\", but we are not sure. What is certain is that it came up during a dinner that  Bob ,  David  and  Sol  had in 2015. David thinks that Bob invented the name, Bob doesn't remember and Sol thinks the waiter might have come up with it (although we can almost certainly rule that option out). It certainly is better than the previous name \"IAMF\". We now use \"Mimi\" purely as a name of the package, not as an acronym.", 
            "title": "What's up with the name?"
        }, 
        {
            "location": "/faq/#how-do-i-use-a-multivariate-distribution-for-a-parameter-within-a-component", 
            "text": "You might want to use a multivariate distribution to capture the covariance between estimated coefficient parameters.  For example, an estimated polynomial can be represented as a multivariate Normal distribution, with a variance-covariance matrix.  Do use this, define the parameter in the component with a vector type, like here:  @defcomp example begin\n    cubiccoeffs::Vector{Float64} = Parameter()\nend  Then in the model construction, set the parameter with a multivariate distribution (here the parameters are loaded from a CSV file):  cubicparams = readdlm( ../data/cubicparams.csv , ',')\nsetparameter(m, :example, :cubiccoeff, MvNormal(squeeze(cubicparams[1,:], 1), cubicparams[2:4,:]))  Here,  ../data/cubicparams.csv  is a parameter definition file that looks something like this:  # Example estimated polynomial parameter\n# First line: linear, quadratic, cubic\n# Lines 2-4: covariance matrix\n-3.233303,1.911123,-.1018884\n1.9678593,-.57211657,.04413228\n-.57211657,.17500949,-.01388863\n.04413228,-.01388863,.00111965", 
            "title": "How do I use a multivariate distribution for a parameter within a component?"
        }, 
        {
            "location": "/faq/#how-do-i-use-component-references", 
            "text": "Component references allow you to write cleaner model code when connecting components.  The  addcomponent  function returns a reference to the component that you just added:  mycomponent = addcomponent(model, MyComponent)  If you want to get a reference to a component after the  addcomponent  call has been made, you can construct the reference as:  mycomponent = ComponentReference(model, :MyComponent)  You can use this component reference in place of the  setparameter  and  connectparameter  calls.", 
            "title": "How do I use component references?"
        }, 
        {
            "location": "/faq/#references-in-place-of-setparameter", 
            "text": "The line  setparameter(model, :MyComponent, :myparameter, myvalue)  can be written as  mycomponent[:myparameter] = myvalue , where  mycomponent  is a component reference.", 
            "title": "References in place of setparameter"
        }, 
        {
            "location": "/faq/#references-in-place-of-connectparameter", 
            "text": "The line  connectparameter(model, :MyComponent, :myparameter, :YourComponent, :yourparameter)  can be written as  mycomponent[:myparameter] = yourcomponent[:yourparameter] , where  mycomponent  and  yourcomponent  are component references.", 
            "title": "References in place of connectparameter"
        }, 
        {
            "location": "/reference/", 
            "text": "Reference\n\n\n#\n\n\nMimi.components\n \n \nFunction\n.\n\n\ncomponents(m::Model)\n\n\n\n\nList all the components in model \nm\n.\n\n\n#\n\n\nMimi.variables\n \n \nFunction\n.\n\n\nvariables(m::Model, componentname::Symbol)\n\n\n\n\nList all the variables of \ncomponentname\n in model \nm\n.\n\n\n#\n\n\nMimi.addcomponent\n \n \nFunction\n.\n\n\nAdd a component to a model.\n\n\n#\n\n\nMimi.setparameter\n \n \nFunction\n.\n\n\nSet the parameter of a component in a model to a given value.\n\n\nSet a component parameter as \nsetparameter(reference, name, value)\n.\n\n\n#\n\n\nMimi.connectparameter\n \n \nFunction\n.\n\n\nBind the parameter of one component to a variable in another component.\n\n\n#\n\n\nMimi.setleftoverparameters\n \n \nFunction\n.\n\n\nSet all the parameters in a model that don't have a value and are not connected to some other component to a value from a dictionary.\n\n\n#\n\n\nMimi.getdataframe\n \n \nFunction\n.\n\n\ngetdataframe(m::Model, componentname::Symbol, name::Symbol)\n\n\n\n\nReturn the values for variable \nname\n in \ncomponentname\n of model \nm\n as a DataFrame.\n\n\n#\n\n\nBase.run\n \n \nFunction\n.\n\n\nrun(m::Model)\n\n\n\n\nRun model \nm\n once.\n\n\n#\n\n\nMimi.@defcomp\n \n \nMacro\n.\n\n\nDefine a new component.", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#reference", 
            "text": "#  Mimi.components     Function .  components(m::Model)  List all the components in model  m .  #  Mimi.variables     Function .  variables(m::Model, componentname::Symbol)  List all the variables of  componentname  in model  m .  #  Mimi.addcomponent     Function .  Add a component to a model.  #  Mimi.setparameter     Function .  Set the parameter of a component in a model to a given value.  Set a component parameter as  setparameter(reference, name, value) .  #  Mimi.connectparameter     Function .  Bind the parameter of one component to a variable in another component.  #  Mimi.setleftoverparameters     Function .  Set all the parameters in a model that don't have a value and are not connected to some other component to a value from a dictionary.  #  Mimi.getdataframe     Function .  getdataframe(m::Model, componentname::Symbol, name::Symbol)  Return the values for variable  name  in  componentname  of model  m  as a DataFrame.  #  Base.run     Function .  run(m::Model)  Run model  m  once.  #  Mimi.@defcomp     Macro .  Define a new component.", 
            "title": "Reference"
        }
    ]
}